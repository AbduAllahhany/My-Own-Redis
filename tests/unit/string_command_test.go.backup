package tests

import (
	"bufio"
	"bytes"
	"net"
	"sync"
	"testing"
	"time"

	"github.com/codecrafters-io/redis-starter-go/app/engine"
	"github.com/codecrafters-io/redis-starter-go/app/resp"
	"github.com/codecrafters-io/redis-starter-go/app/server"
)

func TestSet_BasicOperation(t *testing.T) {
	// Initialize commands
	server.InitCommands()

	// Create test database
	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	tests := []struct {
		name        string
		args        []string
		shouldError bool
		expectedKey string
		expectedVal string
	}{
		{
			name:        "Valid SET command",
			args:        []string{"key1", "value1"},
			shouldError: false,
			expectedKey: "key1",
			expectedVal: "value1",
		},
		{
			name:        "SET with spaces in value",
			args:        []string{"key2", "value with spaces"},
			shouldError: false,
			expectedKey: "key2",
			expectedVal: "value with spaces",
		},
		{
			name:        "Invalid SET - missing value",
			args:        []string{"key3"},
			shouldError: true,
		},
		{
			name:        "Invalid SET - no arguments",
			args:        []string{},
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := server.Command{
				Name: "SET",
				Args: tt.args,
			}

			request := &Request{
				Serv:   server,
				Conn:   &conn,
				Reader: reader,
				Writer: writer,
				Cmd:    &cmd,
				ConnId: "test-conn",
			}

			result, err := set(request)

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			// Check response
			expected := resp.SimpleStringDecoder("OK")
			if !bytes.Equal(result, expected) {
				t.Errorf("Expected %q, got %q", string(expected), string(result))
			}

			// Check if key was stored
			db.Mu.RLock()
			stored := (*db.Dict)[tt.expectedKey]
			db.Mu.RUnlock()

			if stored == nil {
				t.Error("Expected key to be stored but it wasn't")
			} else if stored.Value() != tt.expectedVal {
				t.Errorf("Expected stored value %q, got %v", tt.expectedVal, stored.Value())
			}
		})
	}
}

func TestSet_WithExpiration(t *testing.T) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	tests := []struct {
		name        string
		args        []string
		shouldError bool
		expectTTL   bool
	}{
		{
			name:        "SET with EX (seconds)",
			args:        []string{"key1", "value1", "EX", "10"},
			shouldError: false,
			expectTTL:   true,
		},
		{
			name:        "SET with PX (milliseconds)",
			args:        []string{"key2", "value2", "PX", "1000"},
			shouldError: false,
			expectTTL:   true,
		},
		{
			name:        "SET with invalid EX",
			args:        []string{"key3", "value3", "EX", "invalid"},
			shouldError: true,
		},
		{
			name:        "SET with missing EX value",
			args:        []string{"key4", "value4", "EX"},
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := Command{
				Name: "SET",
				Args: tt.args,
			}

			request := &Request{
				Serv:   server,
				Conn:   &conn,
				Reader: reader,
				Writer: writer,
				Cmd:    &cmd,
				ConnId: "test-conn",
			}

			result, err := set(request)

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			// Check response
			expected := resp.SimpleStringDecoder("OK")
			if !bytes.Equal(result, expected) {
				t.Errorf("Expected %q, got %q", string(expected), string(result))
			}

			// Check if TTL was set
			if tt.expectTTL {
				db.Mu.RLock()
				stored := (*db.Dict)[tt.args[0]]
				db.Mu.RUnlock()

				if stored == nil {
					t.Error("Expected key to be stored but it wasn't")
				} else if !stored.HasExpiration() {
					t.Error("Expected key to have expiration but it doesn't")
				}
			}
		})
	}
}

func TestSet_WithGetOption(t *testing.T) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	// Pre-populate with a key
	(*db.Dict)["existing"] = engine.RedisString{
		Data:       "old_value",
		Expiration: time.Time{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	tests := []struct {
		name     string
		args     []string
		expected string
	}{
		{
			name:     "SET GET with existing key",
			args:     []string{"existing", "new_value", "GET"},
			expected: "+old_value\r\n",
		},
		{
			name:     "SET GET with non-existing key",
			args:     []string{"non_existing", "value", "GET"},
			expected: "+\r\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := Command{
				Name: "SET",
				Args: tt.args,
			}

			request := &Request{
				Serv:   server,
				Conn:   &conn,
				Reader: reader,
				Writer: writer,
				Cmd:    &cmd,
				ConnId: "test-conn",
			}

			result, err := set(request)
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if string(result) != tt.expected {
				t.Errorf("Expected %q, got %q", tt.expected, string(result))
			}
		})
	}
}

func TestGet_BasicOperation(t *testing.T) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	// Pre-populate with test data
	(*db.Dict)["key1"] = engine.RedisString{
		Data:       "value1",
		Expiration: time.Time{},
	}
	(*db.Dict)["expired"] = engine.RedisString{
		Data:       "expired_value",
		Expiration: time.Now().Add(-time.Hour),
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	tests := []struct {
		name        string
		args        []string
		expected    string
		shouldError bool
	}{
		{
			name:     "GET existing key",
			args:     []string{"key1"},
			expected: "+value1\r\n",
		},
		{
			name:     "GET non-existing key",
			args:     []string{"non_existing"},
			expected: "$-1\r\n",
		},
		{
			name:     "GET expired key",
			args:     []string{"expired"},
			expected: "$-1\r\n",
		},
		{
			name:        "GET with wrong number of args",
			args:        []string{"key1", "extra"},
			shouldError: true,
		},
		{
			name:        "GET with no args",
			args:        []string{},
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := Command{
				Name: "GET",
				Args: tt.args,
			}

			request := &Request{
				Serv:   server,
				Conn:   &conn,
				Reader: reader,
				Writer: writer,
				Cmd:    &cmd,
				ConnId: "test-conn",
			}

			result, err := get(request)

			if tt.shouldError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if string(result) != tt.expected {
				t.Errorf("Expected %q, got %q", tt.expected, string(result))
			}
		})
	}
}

func TestGet_WithWrongType(t *testing.T) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	// Add a list instead of string
	(*db.Dict)["list_key"] = engine.RedisList{
		Data:       []string{"item1", "item2"},
		Expiration: time.Time{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	cmd := Command{
		Name: "GET",
		Args: []string{"list_key"},
	}

	request := &Request{
		Serv:   server,
		Conn:   &conn,
		Reader: reader,
		Writer: writer,
		Cmd:    &cmd,
		ConnId: "test-conn",
	}

	result, err := get(request)
	if err == nil {
		t.Error("Expected error for wrong type but got none")
		return
	}

	expectedError := resp.ErrorDecoder("WRONGTYPE Operation against a key holding the wrong kind of value")
	if !bytes.Equal(result, expectedError) {
		t.Errorf("Expected %q, got %q", string(expectedError), string(result))
	}
}

// Benchmark tests for string commands
func BenchmarkSet_BasicOperation(b *testing.B) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	cmd := Command{
		Name: "SET",
		Args: []string{"key", "value"},
	}

	request := &Request{
		Serv:   server,
		Conn:   &conn,
		Reader: reader,
		Writer: writer,
		Cmd:    &cmd,
		ConnId: "test-conn",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		request.Cmd.Args[0] = "key" + string(rune(i%1000))
		_, _ = set(request)
	}
}

func BenchmarkSet_WithExpiration(b *testing.B) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	cmd := Command{
		Name: "SET",
		Args: []string{"key", "value", "EX", "10"},
	}

	request := &Request{
		Serv:   server,
		Conn:   &conn,
		Reader: reader,
		Writer: writer,
		Cmd:    &cmd,
		ConnId: "test-conn",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		request.Cmd.Args[0] = "key" + string(rune(i%1000))
		_, _ = set(request)
	}
}

func BenchmarkGet_ExistingKey(b *testing.B) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	// Pre-populate with data
	for i := 0; i < 1000; i++ {
		key := "key" + string(rune(i))
		(*db.Dict)[key] = engine.RedisString{
			Data:       "value",
			Expiration: time.Time{},
		}
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	cmd := Command{
		Name: "GET",
		Args: []string{"key0"},
	}

	request := &Request{
		Serv:   server,
		Conn:   &conn,
		Reader: reader,
		Writer: writer,
		Cmd:    &cmd,
		ConnId: "test-conn",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		request.Cmd.Args[0] = "key" + string(rune(i%1000))
		_, _ = get(request)
	}
}

func BenchmarkGet_NonExistingKey(b *testing.B) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}
	conn, _ := net.Pipe()
	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	cmd := Command{
		Name: "GET",
		Args: []string{"non_existing"},
	}

	request := &Request{
		Serv:   server,
		Conn:   &conn,
		Reader: reader,
		Writer: writer,
		Cmd:    &cmd,
		ConnId: "test-conn",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		request.Cmd.Args[0] = "non_existing" + string(rune(i%1000))
		_, _ = get(request)
	}
}

func BenchmarkSetGet_Concurrent(b *testing.B) {
	server.InitCommands()

	dict := make(map[string]engine.RedisObj)
	db := engine.DbStore{
		Dict: &dict,
		Mu:   &sync.RWMutex{},
	}

	server := &Server{Db: &db}

	b.RunParallel(func(pb *testing.PB) {
		conn, _ := net.Pipe()
		reader := bufio.NewReader(conn)
		writer := bufio.NewWriter(conn)

		i := 0
		for pb.Next() {
			key := "key" + string(rune(i%100))

			if i%2 == 0 {
				// SET operation
				cmd := Command{
					Name: "SET",
					Args: []string{key, "value"},
				}
				request := &Request{
					Serv:   server,
					Conn:   &conn,
					Reader: reader,
					Writer: writer,
					Cmd:    &cmd,
					ConnId: "test-conn",
				}
				_, _ = set(request)
			} else {
				// GET operation
				cmd := Command{
					Name: "GET",
					Args: []string{key},
				}
				request := &Request{
					Serv:   server,
					Conn:   &conn,
					Reader: reader,
					Writer: writer,
					Cmd:    &cmd,
					ConnId: "test-conn",
				}
				_, _ = get(request)
			}
			i++
		}
	})
}
